// This file demonstrates the compile-time linearity guarantees provided by
// the Balance resource type in the token contract.
//
// The Balance type generated by the WIT resource definition doesn't implement
// Copy or Clone, which means it has move semantics enforced by the Rust compiler.

use testlib::*;

// This would fail at compile time if uncommented:
/*
fn try_to_copy_balance() {
    // Hypothetical balance resource
    let balance: token::Balance = get_balance_somehow();

    // This moves balance
    use_balance(balance);

    // This would be a compile error: use of moved value
    use_balance(balance); // ERROR: value used here after move
}

fn try_to_clone_balance() {
    let balance: token::Balance = get_balance_somehow();

    // This would fail because Balance doesn't implement Clone
    let balance2 = balance.clone(); // ERROR: no method named `clone` found
}
*/

// Instead, the correct pattern is:
#[allow(dead_code)]
fn correct_balance_usage() {
    // In the actual token contract:
    // 1. Withdraw creates a Balance resource
    // 2. The Balance can be split into multiple smaller balances
    // 3. Balances can be merged back together
    // 4. Finally, deposit consumes the balance

    // Each operation that takes a Balance consumes it (moves it),
    // preventing double-spending at compile time.
}

#[tokio::test]
async fn test_linearity_documentation() -> Result<()> {
    // This test exists to document the compile-time guarantees.
    // The actual linearity is enforced by the type system, not runtime checks.
    println!("Balance resources provide compile-time linearity guarantees:");
    println!("- Balance doesn't implement Copy or Clone");
    println!("- Operations that take Balance consume it (move semantics)");
    println!("- Double-spending is prevented at compile time");
    println!("- The Rust compiler enforces single-use of each balance");

    Ok(())
}
